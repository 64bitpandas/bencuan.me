---
import ColorLayout from './_ColorLayout.astro';
import { labToHex, isLight } from '../../utils/colors';
import pantoneNames from '../../color-books/_pantone-color-names.json';
import favoritesPreset from '../../color-books/_favorites.json';

const title = "Explorer";

// 1. Load all color books
// 1. Load all color books
const bookFiles = import.meta.glob('../../color-books/*.json', { eager: true });

const books = Object.entries(bookFiles)
  .filter(([path]) => !path.split('/').pop().startsWith('_'))
  .map(([_, mod]) => mod.default || mod);

// 2. Group Books by Standard/Prefix
const standardsMap = new Map();

books.forEach(book => {
  let prefix = book.prefix.trim();
  // Special Merges
  if (prefix === 'PANTONE') prefix = 'PANTONE'; // Merges 'PANTONE ' and 'PANTONE'
  if (book.title.includes('TOYO')) prefix = 'TOYO'; // Simplify TOYO
  
  if (!standardsMap.has(prefix)) {
    standardsMap.set(prefix, []);
  }
  standardsMap.get(prefix).push(book);
});

const standards = Array.from(standardsMap.keys()).sort();
const currentStd = Astro.url.searchParams.get('std') || (standards.includes('PANTONE') ? 'PANTONE' : standards[0]);

// 3. Process Colors for Current Standard
const currentBooks = standardsMap.get(currentStd) || [];
let colors = [];

currentBooks.forEach(book => {
  const records = book.records;
  // If book has "records" object (most seem to)
  if (records) {
     Object.values(records).forEach((record: any) => {
        let hex = '#000000';
        if (record.components && record.components.length === 3) {
            // Convert LAB to Hex
            hex = labToHex(record.components[0], record.components[1], record.components[2]);
        }
        
        // Friendly Name Matching
        let friendly = '';
        // Try to find numeric code in name, e.g. "PANTONE 17-0215 TCX" -> "17-0215"
        // Simple regex to find X-XXXX or XX-XXXX
        const codeMatch = record.name.match(/(\d{2}-\d{4})/);
        if (codeMatch && pantoneNames[codeMatch[1]]) {
            friendly = pantoneNames[codeMatch[1]].name.replace(/-/g, ' ');
            // If the map has a hex override, should we use it? 
            // The instructions say "The 'components' are in CIELAB format... helper function to convert".
            // But _pantone-color-names.json has HEX. 
            // I'll stick to the LAB conversion for accuracy to the book unless explicitly broken, 
            // but the prompt implies using the friendly name JSON for names. 
        }

        colors.push({
            name: record.name,
            friendly: friendly, // Only if matched
            hex: hex,
            code: record.code,
            isLight: isLight(hex)
        });
     });
  }
});

// Serialize for client use
const activeFavoritesPreset = favoritesPreset[currentStd] || [];

---

<ColorLayout title={title} currPage="explorer">
  <div class="explorer-container">
    {/* Sidebar Controls */}
    <aside class="explorer-sidebar">
      
      {/* Standard Selector */}
      <div class="controls-section">
        <h3>Standard</h3>
        <select class="standard-select" onchange="window.location.href=`?std=${this.value}`">
          {standards.map(std => (
            <option value={std} selected={std === currentStd}>{std} {std === 'PANTONE' && 'SOLID COATED'}</option> 
            // Added hardcoded subtitle for PANTONE as per screenshot demo feel, but dynamic is better. 
            // Reverting to just name for generic safety.
          ))}
        </select>
        {currentStd === 'PANTONE' && <div style="font-size: 0.8rem; margin-top: 0.5rem; opacity: 0.6;">SOLID COATED & OTHERS</div>}
      </div>

      {/* Favorites Panel */}
      <div class="controls-section">
        <h3><i class="ph-fill ph-star"></i> favorites</h3>
        <div class="favorites-actions">
           <button id="btn-unfilter" class="secondary">un<b>filter</b></button> 
           <button id="btn-preset">preset</button>
           <button id="btn-clear">clear</button>
        </div>
      </div>

      {/* Size Slider */}
      <div class="size-slider-container controls-section">
        <h3>size</h3>
        <input type="range" id="size-slider" min="100" max="300" value="150" />
      </div>

    </aside>

    {/* Main Grid */}
    <div class="explorer-main">
      <h1 style="font-family: var(--font-ui); font-size: 2rem; margin-top: 0; margin-bottom: 2rem;">
        <span class="u-bold">{currentStd}</span> {currentBooks.length > 0 && currentBooks[0].title.includes('Solid Coated') ? 'SOLID COATED' : ''}
        {/* Dynamic Title logic is tricky without knowing all book titles, but taking a guess or leaving simple */}
      </h1>

      <div class="swatch-grid" id="swatch-grid">
        {colors.map((color, index) => (
          <div 
            class="swatch-card" 
            data-name={color.name} 
            data-hex={color.hex}
            data-friendly={color.friendly}
            data-light={color.isLight}
          >
             <div class="swatch-color" style={`background-color: ${color.hex}`}>
               <button class="fav-btn" aria-label="Favorite">
                 <i class="ph ph-star"></i>
               </button>
               <div class="copied-overlay">Copied!</div>
             </div>
             <div class="swatch-info">
               <div class="swatch-code">{color.name}</div>
               <div class="swatch-friendly">{color.friendly || <span style="visibility:hidden">-</span>}</div>
               <div class="swatch-hex">{color.hex}</div>
             </div>
          </div>
        ))}
      </div>
    </div>
  </div>

  <script define:vars={{ activeFavoritesPreset, favoritesPreset }}>
    import { colord } from 'colord';

    // --- State & DOM Elements ---
    const grid = document.getElementById('swatch-grid');
    const slider = document.getElementById('size-slider');
    const filterBtn = document.getElementById('btn-unfilter');
    const presetBtn = document.getElementById('btn-preset');
    const clearBtn = document.getElementById('btn-clear');
    const header = document.getElementById('main-header');

    let favorites = JSON.parse(localStorage.getItem('bencuan_colors_favs') || '[]');
    let isFiltered = false;

    // --- Helpers ---
    function updateFavStorage() {
        localStorage.setItem('bencuan_colors_favs', JSON.stringify(favorites));
        renderFavState();
    }

    function renderFavState() {
        // Update Icons
        document.querySelectorAll('.swatch-card').forEach(card => {
            const name = card.getAttribute('data-name');
            const btn = card.querySelector('.fav-btn');
            const icon = btn.querySelector('i');
            
            if (favorites.includes(name)) {
                btn.classList.add('active');
                icon.classList.remove('ph-star');
                icon.classList.add('ph-star-fill'); // Or proper filled class
                icon.classList.add('ph-fill');
            } else {
                btn.classList.remove('active');
                icon.classList.remove('ph-star-fill');
                icon.classList.remove('ph-fill');
                icon.classList.add('ph-star');
            }
        });
        
        applyFilter();
    }
    
    function applyFilter() {
        // Re-read isFiltered state from UI or simple toggle? 
        // Instructions: "Filter button should hide all colors except favorites, then read 'unfilter'"
        document.querySelectorAll('.swatch-card').forEach(card => {
            const name = card.getAttribute('data-name');
            if (isFiltered && !favorites.includes(name)) {
                card.style.display = 'none';
            } else {
                card.style.display = 'flex';
            }
        });
        
        // Update Button Text
        if (isFiltered) {
            filterBtn.innerHTML = 'un<b>filter</b>';
        } else {
            filterBtn.innerHTML = '<b>filter</b>';
        }
    }

    // --- Interaction Logic ---
    
    // 1. Slider
    slider.addEventListener('input', (e) => {
        grid.style.setProperty('--swatch-size', `${e.target.value}px`);
    });

    // 2. Favorites Interactions
    // Delegate events from grid
    grid.addEventListener('click', (e) => {
        const target = e.target;
        const card = target.closest('.swatch-card');
        if (!card) return;

        // Check if Fav Button clicked
        if (target.closest('.fav-btn')) {
            const name = card.getAttribute('data-name');
            e.stopPropagation(); // Don't trigger copy/select
            
            if (favorites.includes(name)) {
                favorites = favorites.filter(f => f !== name);
            } else {
                favorites.push(name);
            }
            updateFavStorage();
            return;
        }

        // Swatch Selection / Copy
        handleSwatchClick(card);
    });

    async function handleSwatchClick(card) {
        // Animation
        card.classList.add('selected');
        setTimeout(() => card.classList.remove('selected'), 600);
        
        const hex = card.getAttribute('data-hex');
        
        // Copy
        await navigator.clipboard.writeText(hex);
        
        // Show Overlay
        const overlay = card.querySelector('.copied-overlay');
        overlay.classList.add('visible');
        setTimeout(() => overlay.classList.remove('visible'), 1500);
        
        // Update Header
        if (header) {
            header.style.backgroundColor = hex;
            // Determine contrast
            const isLight = colord(hex).isLight();
            header.style.color = isLight ? '#000000' : '#FFFFFF';
        }
    }

    // 3. Toolbar Buttons
    filterBtn.addEventListener('click', () => {
       isFiltered = !isFiltered;
       applyFilter();
    });

    presetBtn.addEventListener('click', () => {
        // Override favorites with preset
        // activeFavoritesPreset is passed from frontmatter logic
        // It's an array of objects {name, note}. We just need name.
        if (activeFavoritesPreset && activeFavoritesPreset.length) {
            favorites = activeFavoritesPreset.map(f => f.name);
            updateFavStorage();
            // Optionally auto-filter?
            isFiltered = true;
            applyFilter();
        }
    });

    clearBtn.addEventListener('click', () => {
        favorites = [];
        updateFavStorage();
    });

    // Initial Render
    renderFavState();
    
    // Mobile Check
    if (window.innerWidth <= 768) {
        document.querySelector('.size-slider-container').style.display = 'none';
        // Hide favorites panel too? Instructions: "Hide favorites and size popups"
        // Since we didn't implement popups but sidebars, we hide sections.
        document.querySelectorAll('.controls-section').forEach(el => {
            if (el.querySelector('h3').textContent.includes('favorites') || el.querySelector('h3').textContent.includes('size')) {
                el.style.display = 'none';
            }
        });
    }

  </script>
</ColorLayout>
